# 2021前端面试及答案----（全部涉及）



# 2021面试题–HTML篇

## 1、的title和alt有什么区别?

1、alt： 图片加载失败时，显示在网页上的替代文字
2、title： 鼠标放在上面时显示的文字
3、alt 是必要属性，title 非必要

## 2、 html5有哪些新特性、移除了那些元素？

（1）新增特性
　　a、新增标签 
　　    article、aside、audio、bdi、canvas、command、datalist、details、embed、figcaption、figure、footer、header、
　　hgroup、keygen、mark、meter、nav、output、progress、rp、rt、ruby、section、source、summary、time、track、video
　　其中常用标签：article、aside、audio、video、canvas、footer、header、nav、section
　　b、新增localStorage、sessionStorage
　　c、新增contenteditable属性 （任何dom节点只要加上contenteditable="true"就可以变得可编辑）
　　d、Geolocation 地理定位
（2）移除特性
　　<basefont> 默认字体，不设置字体，以此渲染，<font> 字体标签，<center> 水平居中，<u> 下划线，<big> 大字体 
　　<strike> 中横线，<tt> 文本等宽


## 3、WEB标准以及W3C标准是什么?

1、标签闭合
2、标签小写
3、嵌套正确
4、外部链接css和js
5、提倡结构、表现和行为相分离（HTML结构、CSS表现、JavaScript行为）


## 4、xhtml和html有什么区别?

1、XHTML 元素必须被正确地嵌套。
2、XHTML 元素必须被关闭。
3、标签名必须用小写字母。
4、XHTML 文档必须拥有根元素。


## 5、Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?

1. <!DOCTYPE> 声明位于文档中的最前面，处于 <html> 标签之前。告知浏览器以何种模式来渲染文档。 

2. 严格模式的排版和 JS 运作模式是  以该浏览器支持的最高标准运行。

3. 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。

4. DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现

  

## 6.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？

行内元素
1、设置宽高无效
2、对margin仅设置左右方向有效，上下无效；padding上下左右都有效，会撑大空间
3、不会自动进行换行

块级元素
1、能够识别设置宽高
2、margin和padding的上下左右均对其有效
3、独占一行


## 7、HTML全局属性(global attribute)有哪些

html属性赋予元素意义和语境，可以用于任何的html元素
1、class：为元素设置类标识
2、data-*：为元素增加自定义属性
3、id：元素id，文档内唯一
4、lang：元素内容的语言
5、style：行内css样式
6、title：元素相关的建议信息
7、dir：规定元素中内容的文本方向（ltr：从左到右， rtl：从右到左）
8、contenteditable：html新增属性，设置true后可编辑元素
9、hidden：隐藏一个html元素


## 8、Canvas和SVG有什么区别？

Canvas
1、可伸缩矢量图形 
2、放大缩小不会失真

SVG
1、HTML5新加的元素
2、使用XML描述2D图形的语言


## 9、HTML5 为什么只需要写 DOCTYPE HTML？

<!DOCTYPE HTML> 是文档类型声明，它声明了文档类型为html5，告诉浏览器和其他开发者，该文档使用的是html5标准


# 2021前端面试题–CSS篇

## 1、实现一个div在不同分辨率下的水平垂直居中

```css
.box {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border: 1px solid pink;
      width: 100px;
      height: 100px;
}
```




## 2、左右固定，中间自适应样式

```html
<style>
    .box {
      display: flex;
      height: 200px;
    }
    .left {
      flex: 0 0 200px;
      background-color: pink;
    }
    .center {
      flex: 1;
      background-color: yellow;
    }
    .right {
      flex: 0 0 200px;
      background-color: skyblue;
    }
  </style>
</head>
<body>
  <div class="box">
      <div class="left"></div>
      <div class="center"></div>
      <div class="right"></div>
  </div>
</body>
```




## 3、阐述清楚浮动的几种方式（常见问题）

### 1、浮动的产生

float: left/right（设置后产生浮动）
初衷：浮动原先的设计初衷是为了实现文字环绕效果
结果：父元素高度塌陷，理解起来就是元素浮动飘起来了，失去高度，下面的元素会顶上来，就造成了原有的元素背景不见了，margin/padding也不能正常显示

### 2、解决浮动的方法

#### （1）clear: both，在元素最后下加一个元素设置clear：both属性，缺点是会增加多余无用的html元素

```
<div class="container"> 
  <div class="left">left浮动</div> 
  <div class="right">right浮动</div>
  <div  style="clear:both;"></div>
</div>
```



#### （2）使用after伪元素

.box 父元素

```
.box::after {
    content: ' ';
    display: block;
    clear: both;
 }
```



#### （3）给父元素设置明确的高度，缺点是并不是所有元素的高度都是固定

#### （4）给父级元素设置overflow:hidden, 缺点：不能和position配合使用



## 4、解释css sprites ，如何使用？

1、什么是精灵图
将一些小图标放在一张图上

2、精灵图的优点
减少图片的总大小
减少下载图片资源请求，减小建立连接的消耗

3、精灵图的使用方式
.icon1 {
    background-image: url(css/img/sidebar.png);
    background-repeat: no-repeat;
    background-position: 20px  20px;
 }
// 第一个数是x轴， 第二个数是y轴


## 5、box-sizing常用的属性有哪些？分别有什么作用？

（1）content-box
宽高是元素本身的宽高 不包含border+padding

（2）border-box
元素的宽高已经包含了border+padding

（3）inherit
从父元素继承box-sizing属性


## 6、CSS样式覆盖规则

!important > 内联样式 > id选择 > （class选择 = 伪类选择） > (标签选择 = 伪元素选择)


## 7、请简要描述margin重合问题，及解决方式

问题：相邻两个盒子垂直方向上的margin会发生重叠，只会取比较大的margin

解决：（1）设置padding代替margin
（2）设置float
（3）设置overflow
（4）设置position：absolute 绝对定位
（5）设置display： inline-block


## 8、对标签有什么理解

1、meta是html文档头部的一个标签，这个标签对用户不可见，是给搜索引擎看的。

2、meta标签属性用法分成两大类(详情看主页)

 3、<meta charset="UTF-8"> 使用的编码格式，大部分是utf-8!



## 9、display none visibility hidden区别？

visibility:hidden和display:none有以下几种不同，分别是1、作用不同；2、使用后HTML元素有所不同；3、定义不同。

1、作用不同:

visibility:hidden将元素隐藏，但是在网页中该占的位置还是占着。

display:none将元素的显示设为无，即在网页中不占任何的位置。

2、使用后HTML元素有所不同:

visibility:hidden，使用该属性后，HTML元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在，也即是说它仍具有高度、宽度等属性值。

display:none，使用该属性后，HTML元素（对象）的宽度、高度等各种属性值都将“丢失”。

3、定义不同:

visibility属性指定一个元素是否是可见的。

display这个属性用于定义建立布局时元素生成的显示框类型。
————————————————
版权声明：本文为CSDN博主「Mr， Jia」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/SoLoJia/article/details/123515533

## 10、重绘和回流（哪些情况重绘，哪些回流）

1、回流：当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。每个页面至少需要一次回流，就是在页面第一次加载的时候。

2、重绘：当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），这些属性只是影响元素的外观，风格，而不会影响布局的，浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。
触发回流或重绘的情况：
• 页面首次渲染
• 浏览器窗口大小发生改变
• 元素尺寸或位置发生改变
• 元素内容变化（文字数量或图片大小等等）
• 元素字体大小变化
• 添加或者删除可见的DOM元素


## 11、说说你对语义化的理解？

1、去掉或者丢失样式的时候能够让页面呈现出清晰的结构；



2、有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；



3、方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；



4、便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。


## 12、为什么要初始化css样式？

因为浏览器的兼容问题，不同浏览器对有些标签的默认值不同，如果不初始化css，会导致不同浏览器页面间的显示差异。


## 13、移动端适配1px问题

* ```html
  {
  margin: 0;
  padding: 0;
  }
  ul, li{
  list-style: none;
  }
  .hairlines {
  width: 300px;
  margin: 100px auto;
  }
  .hairlines li{
  position: relative;
  border:none;
  margin-top: 10px;
  }
  .hairlines li:after{
  content: '';
  position: absolute;
  left: 0;
  bottom: 0;
  background: #cccccc;
  width: 100%;
  height: 1px;
  -webkit-transform: scaleY(0.5);
  transform: scaleY(0.5);
  -webkit-transform-origin: 0 0;
  transform-origin: 0 0;
  ```

  



## 14、居中为什么要使用transform（为什么不使用marginLeft/Top）

transform 属于合成属性，不会引起整个页面的回流重绘，节省性能消耗，但是占用内存会大些

top/left属于布局属性，会引起页面layout回流和repaint重绘

## 15、介绍css3中position:sticky

sticky 英文字面意思是粘，粘贴，所以可以把它称之为粘性定位。

position: sticky; 基于用户的滚动位置来定位。

粘性定位的元素是依赖于用户的滚动，在 **position:relative** 与 **position:fixed** 定位之间切换。

它的行为就像 **position:relative;** 而当页面滚动超出目标区域时，它的表现就像 **position:fixed;**，它会固定在目标位置。

元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。

这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。

**注意:** Internet Explorer, Edge 15 及更早 IE 版本不支持 sticky 定位。 Safari 需要使用 -webkit- prefix (查看以下实例)。

## 16、上下固定，中间滚动布局如何实现

固定头部和尾部，中间部分可滑动，使用flex布局 

1.设置html，body高度为100% 

2.设置最外层div的布局方式为弹性布局display:flex; 

3.设置最外层div的主轴方向为flex-direction: column;主轴为垂直方向，起点在上沿 

​	row（默认值）：主轴为水平方向，起点在左端。

 	row-reverse：主轴为水平方向，起点在右端。 

​	column：主轴为垂直方向，起点在上沿。 

​	column-reverse：主轴为垂直方向，起点在下沿。

 4.设置最外层div的高度为100% 

5.正常写头部样式 

6.正常写尾部样式 

7.中间样式为flex: 1;overflow: hidden或者overflow:auto;-webkit-overflow-scrolling: touch

   后者在ios手机中滑动会有问题，建议使用插件 

## 17、css实现border渐变

### 1. 使用border-image

CSS 提供了 [border-image](https://developer.mozilla.org/en-US/docs/Web/CSS/border-image) 属性用于给 border 绘制复杂图样，与 [background-image](https://developer.mozilla.org/en-US/docs/Web/CSS/background-image) 类似，我们可以在 border 中展示`image`和`linear-gradient`。

通过 `border-image` 设置渐变色 border 是最简单的方法，只需要两行代码：

```
div {
  border: 4px solid;
  border-image: linear-gradient(to right, #8f41e9, #578aef) 1;
}
 
/* 或者 */
div {
  border: 4px solid;
  border-image-source: linear-gradient(to right, #8f41e9, #578aef);
  border-image-slice: 1;
}
```

这种方式虽然简单但有个明显的缺陷，不支持设置 `border-radius`。接下来会介绍几种支持 `border-radius` 的方法。 

### 2. 使用 background-image

使用 `background-image` 绘制渐变色背景，并且把中间用纯色遮住应该是最容易想到的一种方法，思路是：使用两个盒子叠加，给下层的盒子设置渐变色背景和 padding，给上层盒子设置纯色背景。 

**HTML:** 

```
&lt;div class="border-box border-bg"&gt;
  &lt;div class="content"&gt;
    Lorem ipsum dolor, sit amet consectetur adipisicing elit. Iste ratione
    necessitatibus numquam sunt nihil quos saepe sit facere. Alias accusamus
    voluptate accusantium facere fugiat animi temporibus adipisci! Corporis,
    accusamus tempora.
  &lt;/div&gt;
&lt;/div&gt;
```

**CSS:** 

```
.border-box {
  width: 300px;
  height: 200px;
  margin: 25px 0;
}
 
.border-bg {
  padding: 4px;
  background: linear-gradient(to right, #8f41e9, #578aef);
  border-radius: 16px;
}
 
.content {
  height: 100%;
  background: #222;
  border-radius: 13px; /*trciky part*/
}
```

这种方式的优点是容易理解，兼容性好，缺点是设置 content 的 `border-radius` 会比较 tricky，且不准确 

### 3. 两层元素、background-image、background-clip

为了解决方法 2 中 `border-radius` 不准确的问题，可以使用一个单独的元素作为渐变色背景放在最下层，上层设置一个透明的 border 和纯色的背景（需要设置 background-clip: padding-box 以避免盖住下层元素的 border）, 上下两层设置相同的 `border-radius`。 

**HTML:** 

```
<div class="border-box">
  <div class='border-bg'></div>
  <div class="content">
    Lorem ipsum dolor, sit amet consectetur adipisicing elit. Iste ratione necessitatibus numquam sunt nihil quos
    saepe sit facere. Alias accusamus voluptate accusantium facere fugiat animi temporibus adipisci! Corporis,
    accusamus tempora.
  </div>
</div>
```

**CSS:** 

```
.border-box {
  border: 4px solid transparent;
  border-radius: 16px;
  position: relative;
  background-color: #222;
  background-clip: padding-box; /*important*/
}
 
.border-bg {
  position: absolute;
  top: 0;
  right: 0;
  left: 0;
  bottom: 0;
  z-index: -1;
  margin: -4px;
  border-radius: inherit; /*important*/
  background: linear-gradient(to right, #8f41e9, #578aef);
}
```

### 4. 伪元素、方法3的简化

我们可以使用伪元素替换 `div.border-bg` 以简化HTML结构。 

**HTML:** 

```
<div class="border-box">
  <div class="content">
    Lorem ipsum dolor, sit amet consectetur adipisicing elit. Iste ratione necessitatibus numquam sunt nihil quos
    saepe sit facere. Alias accusamus voluptate accusantium facere fugiat animi temporibus adipisci! Corporis,
    accusamus tempora.
  </div>
</div>
```

**CSS:** 

```
.border-box {
  border: 4px solid transparent;
  border-radius: 16px;
  position: relative;
  background-color: #222;
  background-clip: padding-box; /*important*/
}
 
.border-box::before {
  content: '';
  position: absolute;
  top: 0;
  right: 0;
  left: 0;
  bottom: 0;
  z-index: -1;
  margin: -4px;
  border-radius: inherit; /*important*/
  background: linear-gradient(to right, #8F41E9, #578AEF);
}
```

### 5. 单层元素、background-clip、background-origin、background-image

最后是我觉得最优雅的一种方法，只需要用到单层元素，为其分别设置 `background-clip`、`background-origin`、`background-image` 这三个属性，每个属性设置两组值，第一组用于设置border内的单色背景，第二组用于设置border上的渐变色。

**HTML:**

```
<div class="border-box">
  <div class="content">
    Lorem ipsum dolor, sit amet consectetur adipisicing elit. Iste ratione necessitatibus numquam sunt nihil quos
    saepe sit facere. Alias accusamus voluptate accusantium facere fugiat animi temporibus adipisci! Corporis,
    accusamus tempora.
  </div>
</div>
```

**CSS:** 

```
.border-box {
  border: 4px solid transparent;
  border-radius: 16px;
  background-clip: padding-box, border-box;
  background-origin: padding-box, border-box;
  background-image: linear-gradient(to right, #222, #222), linear-gradient(90deg, #8F41E9, #578AEF);
}
```

目前就能想到这5种方法，个人推荐优先使用4和5 

## 18、纯css实现一个高宽比为1：3的盒子 列举几种方式

HTML:

```
<header>
    <h1>使用纯CSS实现等宽高或其它固定比例的DIV盒子</h1>
</header>
<div class="box ratio1_1">
    <div class="content">Aspect ratio of <span>1:1</span>
    </div>
</div>
<div class="box ratio2_1">
    <div class="content">Aspect ratio of <span>2:1</span>
    </div>
</div>
<div class="box ratio1_2">
    <div class="content">Aspect ratio of <span>1:2</span>
    </div>
</div>
<div class="box ratio4_3">
    <div class="content">Aspect ratio of <span>4:3</span>
    </div>
</div>
<div class="box ratio16_9">
    <div class="content">Aspect ratio of <span>16:9</span>
    </div>
</div>
```

CSS:

```
body {
    /* Important part */
    
    background: orange;
    font-family: 'Lucida Sans Unicode', 'Lucida Grande', sans-serif;
    color: #222;
}
.box {
    display: inline-block;
    position: relative;
    width: 20%;
    margin: 5% 5% 0 0;
    float: left;
    font-size: 12px;
}
.box:before {
    /* Other ratios */
    
    content: "";
    display: block;
    padding-top: 100%;
}
.ratio2_1:before {
    padding-top: 50%;
}
.ratio1_2:before {
    padding-top: 200%;
}
.ratio4_3:before {
    padding-top: 75%;
}
.ratio16_9:before {
    padding-top: 56.25%;
}
.content {
    position: absolute;
    /* Styling */
    
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    background: black;
    padding: 30px;
    text-align: center;
    vertical-align: center;
    text-transform: uppercase;
    color: #fff;
}
.content span {
    font-weight: bold;
    font-size: 3em;
    display: block;
}
header {
    padding: 2em;
    color: #333;
    text-align: center;
}
a {
    font-weight: bold;
}
```



## 19、 css实现一个旋转的圆

```
div{

            width:200px;

            height:200px;

            border:100px solid black;

            border-top-color:pink;

            border-radius:50%;

            animation:fadenum 5s ;

        }
@keyframes fadenum{

   100%{transform:rotate(360deg);}

}
```



## 20、BFC，IFC，FFC的区别

学习目标：BFC、IFC、GFC、FFC
FC是什么？

FC全称Formatting Contexts，是格式上下文。它是W3C CSS2.1规范中的一个概念，它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。

学习内容：
1. BFC
    BFC（Block Formatting Contexts）为块级格式化上下文，BFC是页面上一个隔离的渲染区域，容器里面的子元素不会再布局上影响到外面的元素。

产生BFC的条件：

body根元素
float不为none，意思就是设置了浮动。
overflow的值不为visble，意思是overflow不为默认值的时候，例如overflow为hidden时触发BFC。
position的值不为relative和static
display的值为table-cell、table-caption、inline-block中的任意一个。
BFC的作用是什么呢？

那就是，常见的多栏布局大多会结合块级别的元素浮动，里面的元素就会在一个相对隔离的环境里运行。

BFC应用（不详讲）

同一个BFC下外边距会发生折叠。
BFC可以包含浮动元素（清除浮动）。
BFC可以阻止元素被浮动元素覆盖。
2. IFC
    IFC（Inline Formatting Contexts）是内联格式上下文，IFC的线框高度由其包含的行内元素中最高的实际高度计算而来。

IFC有什么作用呢？
设置水平居中，当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。设置垂直居中，创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle；其他行内元素则可以在此父元素下垂直居中。

3. GFC
    GFC（GridLayout Formatting Contexts）为网格布局格式化上下文，当一个元素的display值设置为grid的时候，该元素就会获得一个独立的渲染区域，通俗一点就是它有自己的渲染规则。通过网格容器上定义网格定义行和网格定义列属性各在网格项目上定义网格行和网格列为每一个网格项目定义位置和空间。
    GFC的作用是什么呢？和table有什么区别？
    同样是一个二维的表格，网格有更丰富的属性来控制行列，控制对齐方式以及更加精细的渲染语义和控制。

4. FFC
    FFC（Flex Formatting Contexts）为自适应格式化上下文，display值为flex或者inline-flex的元素会生成自适应容器，这个属性只有谷歌和火狐支持。

学习总结：
个人理解
BFC就是一个有自己渲染规则的区域，举个栗子，就是学校有校规，班级里又有自己的一套班规，然后BFC就类似于班级，按照自己的一套规则来渲染元素。IFC是行内元素相关的渲染规则，GFC是跟网格布局相关的，FFC是跟弹性盒布局相关的渲染规则。
————————————————
版权声明：本文为CSDN博主「joyce#壳」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_45627939/article/details/108877728

## 21、css3有哪些新特性

CSS3 是 CSS 的升级版本，这套新标准提供了更加丰富且实用的规范，如：盒子模型、列表模块、超链接方式、语言模块、背景和边框、文字特效、多栏布局等等，目前有很多浏览器已经相继支持这项升级的规范，如：Firefox、Chrome、Safari、Opera 等等。在 Web 开发中采用 CSS3 技术将会显著的美化我们的应用程序，提高用户体验，同时也能极大的提高程序的性能。本文将重点介绍一些比较绚丽且实用 CSS3 新特性。

**一：CSS3选择器**

1.基本选择器

2.属性选择器

3.伪类选择器

**二：CSS3边框与圆角**

1.CSS3圆角border-radius

2.盒阴影box-shadow

**三：CSS3背景与渐变**

1.CSS3背景

background-image

2.CSS3渐变

定义：可以在两个或者多个指定颜色之间显示平移的过渡

**四：CSS3过渡**

定义：允许css的属性值在一定时间区间内平滑的过渡，在鼠标点击，鼠标滑过或对元素任何改变中触发，并圆滑地以动画形式改变css的属性值。

**五：CSS3变换**

定义：让一个元素在一个坐标系统中变形，这个属性包含一系列的变形函数，可以移动，旋转，缩放元素。

**六：CSS3动画**

定义：使元素从一种样式逐渐变化到另外一种样式的效果。

以上就是css3新特性有哪些的详细内容，更多请关注php中文网其它相关文章！

## 22、CSS3新增伪类有那些？

一、写在前面
css3中新增了很多的伪类，下面我们将对新增的伪类进行总结。
二、总结
2.1、elem:nth-child(n)选中父元素下的第n个子元素，并且在这个子元素的标签名为elem，n可以接受具体的数值，也可以接受函数。
2.2、elem:nth-last-child(n)作用同上，不过是从后开始查找。
2.3、elem:last-child选中最后一个子元素。
2.4、elem:only-child如果elem是父元素下唯一的子元素，则选中之。
2.5、elem:nth-of-type(n):查找第n个elem标签的元素。可以为一个函数。
2.6、elem:first-of-type:选中父元素下第一个elem类型的元素。
2.7、elem:last-of-type:选中父元素下最后一个elem类型的元素。
2.8、elem:only-of-type:如果父元素下的子元素只有一个elem类型的元素，则选中该元素。
2.9、elem:empty:选中不包含子元素和内容的elem类型的元素。
2.10、elem:target:选中当前活动的elem元素。
2.11、:not(elem):选择非elem元素的每一个元素。
2.12、:enabled:控制表单控件的禁用状态。
2.13、:disabled:控制表单的禁用状态。
2.14、:checked单选框和复选框被选中。
————————————————
版权声明：本文为CSDN博主「卖菜的小白」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_47450807/article/details/123968125

## 23、介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？

1）有两种盒子模型：IE盒模型（border-box）、W3C标准盒模型（content-box）
（2）盒模型：分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分

IE盒模型和W3C标准盒模型的区别：

（1）W3C标准盒模型：属性width，height只包含内容content，不包含border和padding
（2）IE盒模型：属性width，height包含content、border和padding，指的是content
+padding+border。

在ie8+浏览器中使用哪个盒模型可以由box-sizing（CSS新增的属性）控制，默认值为content-box，即标准盒模型；
如果将box-sizing设为border-box则用的是IE盒模型。如果在ie6，7，8中DOCTYPE缺失会将盒子模型解释为IE
盒子模型。若在页面中声明了DOCTYPE类型，所有的浏览器都会把盒模型解释为W3C盒模型
​​​​​​​

盒模型都是由四个部分组成的，分别是margin、border、padding和content。

标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同。标准盒模型的width和height属性的
范围只包含了content，而IE盒模型的width和height属性的范围包含了border、padding和content。

一般来说，我们可以通过修改元素的box-sizing属性来改变元素的盒模型。
————————————————
版权声明：本文为CSDN博主「紫微前端」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/liuhao9999/article/details/123676739

## 24、display:inline-block 什么时候不会显示间隙？

在CSS布局中，如果我们想要将一些元素在同一行显示，其中的一种方法就是把要同行显示的元素设置display属性为inline-block，但是你会发现这些同行显示的inline-block元素之间经常会出现一定的空隙，这就是“换行符/空格间隙问题”。

display：inline；强制变成行内元素

display：block；强制变成块元素

而display：inline-block；顾名思义就是行内块的意思了，他具备了行内元素不换行的特征，同时也有块元素可以设置宽高的特征）

移除空格
使用margin负值
使用font-size：0
letter-spacing
word-spacing
一个是字符间距(letter-spacing)一个是单词间距(word-spacing)，大同小异。据我测试，word-spacing的负值只要大到一定程度，其兼容性上的差异就可以被忽略。因为，貌似，word-spacing即使负值很大，也不会发生重叠。
————————————————
版权声明：本文为CSDN博主「The..Fuir」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_51066068/article/details/124375168

## 25、行内元素float:left后是否变为块级元素？

- 行内块级元素，设置成这个属性的元素会同时拥有行内和块级的特性，最明显的不同是它的默认宽度不是100%，行内元素默认100%宽度占据一行
- 这时候给行内元素设置 padding-top 和 padding-bottom 或者 width、height 都是有效果的

## 26、在网页中的应该使用奇数还是偶数的字体？为什么呢？

使用偶数字体。偶数字号相对更容易和 web 设计的其他部分构成比例关系。Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px时用的是小一号的点。（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。 

## 27、::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用

在 CSS 中伪类一直用 : 表示，如 :hover, :active 等
伪元素在CSS1中已存在，当时语法是用 : 表示，如 :before 和 :after
后来在CSS3中修订，伪元素用 :: 表示，如 ::before 和 ::after，以此区分伪元素和伪类
由于低版本IE对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素
单冒号（：）用于css3的伪类
双冒号（：：）用于css3的伪元素
想让插入的内容出现在其它内容前，使用::before，否者，使用::after；
在代码顺序上，::after生成的内容也比::before生成的内容靠后。
如果按堆栈视角，::after生成的内容会在::before生成的内容之上
::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。:before 和 :after 这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before ::after
————————————————
版权声明：本文为CSDN博主「余杵」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_47775428/article/details/106099877



### 伪类

​	伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。

​	由于状态的变化是非静态的,所以元素达到一个特定状态时，它可能得到一个伪类的样式;当状态改变时，它可能又会失去这个样式。

由此可以看出，它的功能和class有些类似，但它是基于文档之外的抽象，所以叫伪类

常用的伪类：

#### [:hover](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:hover)  :avtive   [:first](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first)    [:first-child](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-child)    [:nth-child](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-child)

### 伪元素

DOM树没有定义的虚拟元素

核心就是需要创建通常不存在于文档中的元素,比如::before :after它选择的是元素指定内容,示
选择元素内容的之前内容或之后内容。

伪元素控制的内容和元素是没有差别的，但是它本身只是基于元素的抽象，并不存在于文档中，所以称为伪元素。用于将特殊的效果添加到某些选择器

伪元素是一个附加至选择器末的关键词，允许你对被选择元素的特定部分修改样式。

注意：一些早期的伪元素曾使用单冒号的语法，所以你可能会在代码或者示例中看到。现代的浏览器为了保持后向兼容，支持早期的带有单双冒号语法的伪元素。
常用的伪元素：

#### [::before](https://developer.mozilla.org/zh-CN/docs/Web/CSS/::before)    [::after](https://developer.mozilla.org/zh-CN/docs/Web/CSS/::after)

### 伪类与伪元素的区别

1）表示方法

CSS2中伪类、伪元素都是以单冒号:表示CSS2.1后规定伪类用单冒号表示，伪元素用双冒号:表示,

浏览器同样接受CSS2时代已经存在的伪元素(:before, :after, :first\fffeline, :first-letter等)的单冒号写法。

CSS2之后所有新增的伪元素(如::selection),应该采用双冒号的写法。

CSS3中，伪类与伪元素在语法上也有所区别，伪元素修改为以:：开头。浏览器对以:开头的伪元素也继续支持，但建议规范书写为：：开头

2）定义不同

伪类即假的类，可以添加类来达到效果

伪元素即假元素，需要通过添加元素才能达到效果

3）总结:

伪类和伪元素都是用来表示文档树以外的"元素"。

伪类和伪元素分别用单冒号:和双冒号::来表示。

伪类和伪元素的区别，关键点在于如果没有伪元素(或伪类),是否需要添加元素才能达到效果，如果是则是伪元素，反之则是伪类。

相同之处:
伪类和伪元素都不出现在源文件和DOM树中。也就是说在htm|源文件中:是看不到伪类和伪元素的。

不同之处:

伪类其实就是基于普通DOM元素而产生的不同状态，他是DOM元素的某一特征。

伪元素能够创建在DOM树中不存在的抽象对象，而且这些抽象对象是能够访问到的。

本篇文章内容来自微信小程序“前端面试星球”。
————————————————
版权声明：本文为CSDN博主「丑小鸭变黑天鹅」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_41880073/article/details/115299511

## 28、如果需要手动写动画，你认为最小时间间隔是多久，为什么?

```
## 如果需要手动写动画，你认为最小时间间隔是多久，为什么？

## 多数显示器默认频率是 60Hz ，即 1 秒刷新 60 次，所以理论上最⼩间隔为

## 1/60*1000ms ＝ 16.7ms
```



## 29、CSS3动画（简单动画的实现，如旋转等）

```
依靠CSS3中提出的三个属性：transition、transform、animation
transition：定义了元素在变化过程中是怎么样的，包含transition-property、transition-duration、transition-timing-function、transition-delay。
transform：定义元素的变化结果，包含rotate、scale、skew、translate。
animation：动画定义了动作的每一帧（@keyframes）有什么效果，包括animation-name，animation-duration、animation-timing-function、animation-delay、animation-iteration-count、animation-direction
————————————————
版权声明：本文为CSDN博主「小码哥・Martin」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/php_martin/article/details/125742557
```



## 30、base64的原理及优缺点

图片转换成base64格式的优缺点

1. 优点

   （1）base64格式的图片是文本格式，占用内存小，转换后的大小比例大概为1/3，降低了资源服务器的消耗；

   （2）网页中使用base64格式的图片时，不用再请求服务器调用图片资源，减少了服务器访问次数。

   （3）base64编码的字符串，更适合不同平台、不同语言的传输；

   （4）算法是编码, 不是压缩, 编码后只会增加字节数，但是算法简单, 几乎不会影响效率，算法可逆, 解码很方便, 不用于私密信息通信;

   （5）解码方便, 但毕竟编码了, 肉眼还是不能直接看出原始内容;

2. 缺点

   （1）base64格式的文本内容较多，存储在数据库中增大了数据库服务器的压力；

   （2）网页加载图片虽然不用访问服务器了，但因为base64格式的内容太多，所以加载网页的速度会降低，可能会影响用户的体验。

   （3）base64无法缓存，要缓存只能缓存包含base64的文件，比如js或者css，这比直接缓存图片要差很多，而且一般HTML改动比较频繁，所以等同于得不到缓存效益。

 

## 31、流体布局、圣杯布局、双飞翼布局

## 32、stylus/sass/less区别

## 33、postcss的作用

## 34、垂直塌陷及解决方法

# 2021面试题–javaScript篇(ES6)

## 1、es6的新特性

const let
模板字符串
箭头函数
函数的参数默认值
对象和数组解构
for...of 和 for...in


## 2、promise的使用，怎么用es5实现promise

## 3、if有作用域吗

只有函数有作用域，if是没有作用域的。

但是有一种情况会让if看上去有作用域，就是在if {}语句中，使用const、let，他们会有块级作用域。


## 4、原型链和作用域链的区别

（1）原型链
当访问一个对象的某个属性时，会先在这个对象本身的属性上找，如果没有找到，会去这个属性的__proto__属性上找，即这个构造函数的prototype，如果还没找到，就会继续在__proto__上查找，
直到最顶层，找不到即为undefined。这样一层一层往上找，彷佛是一条链子串起来，所以叫做原型链。

（2）作用域链
变量取值会到创建这个变量的函数的作用域中取值，如果找不到，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。

（3）区别
作用域是对变量而言，原型链是对于对象的属性而言
作用域链的顶层是window，原型链的顶层是Object


## 5、js判断类型

1、typeof
检测不出null 和 数组，结果都为object，所以typeof常用于检测基本类型

2、instanceof
不能检测出number、boolean、string、undefined、null、symbol类型，所以instancof常用于检测复杂类型以及级成关系

3、constructor
null、undefined没有construstor方法，因此constructor不能判断undefined和null。
但是contructor的指向是可以被改变，所以不安全

4、Object.prototype.toString.call
全类型都可以判断


## 6、数据类型怎么检测

1、typeof
例：console.log(typeof true) // boolean

2、instanceof
例：console.log([1,2] instanceof Array) // true

3、constructor
例： console.log([1, 2].constructor === Array) // ture

4、Object.prototype.toString.call
例：Object.prototype.toString.call([1, 2]) // [object Array]


## 7、普通函数和箭头函数的区别

1、普通函数
可以通过bind、call、apply改变this指向
可以使用new

2、箭头函数
本身没有this指向，
它的this在定义的时候继承自外层第一个普通函数的this
被继承的普通函数的this指向改变，箭头函数的this指向会跟着改变
箭头函数外层没有普通函数时，this指向window
不能通过bind、call、apply改变this指向
使用new调用箭头函数会报错，因为箭头函数没有constructor


## 8、如何用原生js给一个按钮绑定两个onclick事件？

```javascript
var btn = document.getElementById('btn')
btn.addEventListener('click', fn1)
btn.addEventListener('click', fn2)

function fn1 () {
  console.log('我是方法1')  
}

function fn2 () {
  console.log('我是方法2')  
}
```




## 9、document.write和innerHTML的区别

document.write 将内容写入页面，清空替换掉原来的内容，会导致重绘

document.innerHTML 将内容写入某个Dom节点，不会重绘
1
2
3

## 10、栈和堆的区别

1、堆
动态分配内存，内存大小不一，也不会自动释放

2、栈
自动分配相对固定大小的内存空间，并由系统自动释放

3、基本类型都是存储在栈中，每种类型的数据占用的空间的大小是确定的，并由系统自动分配和释放。内存可以及时回收。

4、引用类型的数据都是存储在堆中。准确说是栈中会存储这些数据的地址指针，并指向堆中的具体数据


## 11、undefined 和 null 区别

1、null
什么都没有，表示一个空对象引用（主动释放一个变量引用的兑现那个，表示一个变量不再指向任何引用地址）
2、undefined
没有设置值的变量，会自动赋值undefined
3、区别

```
typeof undefined             // undefined
typeof null                  // object
null === undefined           // false
null == undefined            // true
```




## 12、eval()的作用

eval(string) 函数计算 JavaScript 字符串，并把它作为脚本代码来执行

如果参数是一个表达式，eval() 函数将执行表达式；

如果参数是Javascript语句，eval()将执行 Javascript 语句；

如果执行结果是一个值就返回，不是就返回undefined，如果参数不是一个字符串，则直接返回该参数。

特殊：eval("{b:2}") // 声明一个对象

　eval("（{b:2}）") // 返回对象{b:2}


## 13、JS哪些操作会造成内存泄露

内存泄漏是指一块被分配的内存既不能使用，也不能回收，直到浏览器进程结束。
1、意外的全局变量
2、闭包
3、没有清理的dom元素
dom元素赋值给变量，又通过removeChild移除dom元素。但是dom元素的引用还在内存中
4、被遗忘的定时器或者回调


## 14、谈谈垃圾回收机制方式及内存管理

JavaScript 在定义变量时就完成了内存分配。当不在使用变量了就会被回收，因为其开销比较大，垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。
（1）垃圾回收
标记清除法
当变量进入环境时，将这个变量标记为'进入环境'。当标记离开环境时，标记为‘离开环境’。离开环境的变量会被回收
引用技计数法
跟踪记录每个值被引用的次数，如果没有被引用，就会回收
（2）内存管理
内存分配=》内存使用=》内存回收



## 15、什么是闭包，如何使用它，为什么要使用它？

（1）闭包就是能够读取其它函数内部变量的函数
（2）使用方法：在一个函数内部创建另一个函数
（3）最大用处有两个：读取其他函数的变量值，让这些变量始终保存在内存中
（4）缺点：会引起内存泄漏（引用无法被销毁，一直存在）


## 16、请解释JSONP的工作原理，以及它为什么不是真正的AJAX

JSONP 是一种非正式传输协议，允许用户传递一个callback给服务端，然后服务端返回数据时会将这个callback 参数作为函数名来包裹住 JSON 数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。
当GET请求从后台页面返回时，可以返回一段JavaScript代码，这段代码会自动执行，可以用来负责调用后台页面中的一个callback函数。
它们的实质不同
ajax的核心是通过xmlHttpRequest获取非本页内容
jsonp的核心是动态添加script标签调用服务器提供的js脚本
jsonp只支持get请求，ajax支持get和post请求


## 17、请解释一下JavaScript的同源策略

同源指协议，域名，端口相同，
同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。


## 18、关于JS事件冒泡与JS事件代理（事件委托）

（1）事件冒泡
当一个元素接收到事件的时候 会把他接收到的事件传给自己的父级，一直到window，过程就像冒泡泡 。如果在某一层想要中止冒泡，使用 event.stopPropagation() 。
但是当大量标签大量事件的时候先然不可能为每个元素都加上事件，（事件绑定占用事件，浏览器要跟踪每个事件，占用更多内存。而且并不是所有事件都会被用户使用到）。所以需要事件委托来解决这个问题。
（2）事件委托
将事件给最外层的元素，自己不实现逻辑，由最外层元素来代理。（判断事件源，做不同处理）


## 19、new操作符到底到了什么

（1）var obj = new Fun() 做了三件事

```
var obj  = {}  // 创建一个空对象
obj.__proto__ = Fun.prototype //空对象的__proto__指向构造函数的原型对象
Fun.call(obj) // 构造函数this指向替换成obj
```

（2）实现一个new

```
function _new(fn, ...arg) {
    const obj = Object.create(fn.prototype);
    const ret = fn.apply(obj, arg);
    // 根据规范，返回 null 和 undefined 不处理，依然返回obj，不能使用
    // typeof result === 'object' ? result : obj
    return ret instanceof Object ? ret : obj;
}
```

20、js延迟加载的方式有哪些？

（1）defer属性

```
<script src="test.js" defer="defer"></script>
```


立即下载，但是会等到整个页面都解析完成之后再执行
（2）async属性

```
<script src="test.js" async></script>
```


不让页面等待脚本下载和执行（异步下载），但是无法控制加载的顺序
（3）动态创建script标签
（4）使用定时器延迟
（5）让js最后加载


## 21、promise、async有什么区别

1、什么是Async/Await
async/await是写异步代码的新方式，使用的方式看起来像同步
async/await是基于Promise实现的，它不能用于普通的回调函数。

2、什么是promise
为了解决异步嵌套而产生，让代码更易于理解

区别，async/await让代码更像同步，进一步优化了代码


## 22、== 和 = = =的区别，什么情况下用相等= =

”==” 是判断转换后的值是否相等, 

”===” 是判断值及类型是否完全相等

不需要判断类型时可以使用==


## 23、bind、call、apply的区别

```
var a = {
    user:"渔老板",
    fn: function(arg1, arg2) {
        console.log(this.user)  // 渔老板
        console.log(arg1+ arg2) // 2
    }
}
var b = a.fn
```

1、bind

```
var c = b.bind(a) // 返回一个已经切换this指向的新函数
c(1,1)
```

2、apply
b.apply(a, [1, 1])  // 将b添加到a环境中
第一个参数是this指向的新环境
第二个参数是要传递给新环境的参数
注意： 第一个参数为null时表示指向window

3、call
b.call(a, 1, 1) // 将b添加到a环境中
第一个参数是this指向的新环境
第二、三...个参数是传递给新环境的参数
注意： 第一个参数为null时表示指向window

小结： bind方法可以让函数想什么时候调用就什么时候调用。apply、call方法只是临时改变了this指向



## 24、如何判断链表是否有环

## 25、介绍暂时性死区

在代码块内，使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”。
1

## 26、两个对象如何比较

有思路即可，步骤：
（1）判断两个类型是否对象
（2）判断两个对象key的长度是否一致
（3）判断属性value值的数据类型，根据不同数据类型做比较
    a、是对象，重复这个步骤
    b、是数组，转字符串比较
    c、是基本类型，直接判断


## 27、介绍各种异步方案

（1）回调函数
（2）promise
（3）async/awai


## 28、Promise和Async处理失败的时候有什么区别

（1）Promise错误可以在构造体里面被捕获，而async/await返回的是promise,可以通过catch直接捕获错误。
（2）await 后接的Promise.reject都必须被捕获，否则会中断执行


## 29、JS为什么要区分微任务和宏任务

（1）js是单线程的，但是分同步异步
（2）微任务和宏任务皆为异步任务，它们都属于一个队列
（3）宏任务一般是：script，setTimeout，setInterval、setImmediate
（4）微任务：原生Promise
（5）遇到微任务，先执行微任务，执行完后如果没有微任务，就执行下一个宏任务，如果有微任务，就按顺序一个一个执行微任务


## 30、Promise和setTimeout执行先后的区别

Promise是微任务，setTimeout是宏任务，先执行微任务，如有还有微任务执行完微任务再执行下一个宏任务


## 31、单例、工厂、观察者项目中实际场景

## 32、添加原生事件不移除为什么会内存泄露

比如以下代码：

```
var button = document.getElementById('button');
function onClick(event) {
    button.innerHTML = 'text';
}
button.addEventListener('click', onClick);
```


给元素button添加了一个事件处理器onClick, 而处理器里面使用了button的引用。而老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，因此会导致内存泄漏。

如今，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法，已经可以正确检测和处理循环引用了。换言之，回收节点内存时，不必非要调用 removeEventListener 了。


## 33、setTimeout(0)和setTimeout(2)之间的区别

定时器表面意思是过指定时间后执行，但是真正的含义是每过指定时间后，会有fn进入事件队列
(1)setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行
(2)setTimeout(fn,1) 1毫秒后执行，但是因为要先执行前面的宏任务，所以不一定就是在一毫秒后执行，取决于队列里任务执行的速度


## 34、for…in 和 object.keys的区别

Object.keys不会遍历继承的原型属性
for...in 会遍历继承的原型属性


## 35、XML和JSON的区别？

1，xml是重量级的，json是轻量级的。
2，xml在传输过程中比较占带宽，json占带宽少，易于压缩。
3，xml和json都用在项目交互下，xml多用于做配置文件，json用于数据交互。


## 36、说说你对AMD和Commonjs的理解

两者都是为了实现模块化编程而出现的
（1）commonjs
通常被应用于服务器，在服务器端，模块的加载和执行都在本地完成，因此，CommonJS并不要求模块加载的异步化。
核心思想：
一个单独文件就是一个模块，通过require方法来同步加载要依赖的模块，然后通过extports或则module.exports来导出需要暴露的接口。
（2）AMD
可以实现异步加载依赖模块，预加载，在并行加载js文件同时，还会解析执行该模块。虽然可以并行加载，异步处理，但是加载顺序不一定
（3）CMD
懒加载，虽然会一开始就并行加载js文件，但是不会执行，而是在需要的时候才执行。


## 37、js的涉及模式

单例模式、策略模式、代理模式、迭代器模式...等等等等（了解更多自行百度）


## 38、[“1”, “2”, “3”].map(parseInt) 答案是多少？

这题看到的时候都懵逼了，还是太菜了 qaq
（1）map用法：

```
arr.map(function(el, index, arr) {
    return el
})
```


map方法接收一个函数参数，并且这个函数可以接收三个参数
el：遍历过程中的当前项，
index：遍历过程中的当前下标
arr: 原数组

（2）parseInt用法：
parseInt(str, num) 
根据num解析str，并返回一个整数。
str: 要解析的字符串，如果字符第一个数不能被转换，返回NaN。
num: 基数，介于 2 ~ 36 之间，如果传0，则默认用10计算。num不在区间内，返回NaN

（3）所以这道题，关键点就在num
el和index 相当于 str 和 num 带入一下

```
parseInt('1', 0) // '1' 用基数10算 为1
parseInt('2', 1) // NaN
parseInt('3', 2) // NaN
```



## 39、常见兼容性问题？

（1）事件对象兼容
e  = e || window.event;
（2）阻止事件冒泡兼容
event.stopPropagation? event.stopPropagation():event.cancelBubble=true;
（3）阻止默认行为兼容
evt.preventDefault?evt.preventDefault():evt.returnValue=false;
（4）事件监听兼容
addEventListener  ? addEventListener  : attachEvent()
removeEventListener() ? removeEventListener() : detachEvent()
（5）事件目标对象兼容
var src = event.target || event.srcElement;


## 40、说说你对promise的了解

（1）promise是为解决异步处理回调金字塔问题而产生的
（2）有三种状态，pengding、resolve、reject，状态一旦决定就不会改变
（3）then接收resolve()，catch接收reject()


## 41、模块化开发怎么做？

## 42、介绍js有哪些内置对象？

String对象、Array对象、Object对象、Number对象
Math对象、Date对象、Boolean对象


## 43、说几条写JavaScript的基本规范？

1、不要在同一行声明多个变量
2、使用 === 和 !== 来比较
3、不要使用全局函数
4、变量在使用之前的位置声明（减少变量提升干扰）
5、if用花括号包起来即使只有一行
6、写注释


## 44、JavaScript有几种类型的值？，你能画一下他们的内存图吗？

栈：原始数据类型（Undefined  Null  Boolean  Number  String）
堆：引用数据类型（对象、数组、函数）
内存图求求你自己百度


## 45、href="#"与href=“javascript:void(0)的区别”？

1、# 包含了一个位置信息，默认的锚是#top 也就是网页的上端。在页面很长的时候会使用 # 来定位页面的具体位置，格式为：# + id。

2、javascript:void(0), 仅仅表示一个死链接。

如果你要定义一个死链接请使用 javascript:void(0) 


## 46、对this的理解

1、单独使用，this表示全局对象
2、在函数中，this表示全局对象
3、在对象的一个函数方法中，this表示这个对象
4、可以通过apply、bind来更改this的指向

ps： this永远指向的是最后调用它的对象，仅当它在对象的一个函数方法中时会有差异


## 47、promise.all 返回什么

如果没有报错，返回执行结果[res1, res2,...]
如果报错，则返回第一个报错的promise的结果


## 48、多个await的执行顺序，如果要同步执行如何实现？

使用Promise.all
promise.all是等所有异步操作都完成之后返回结果，相当于让这些异步同步了


# 2021年前端面试题–http浏览器篇

## 1、浏览器缓存有哪些，通常缓存有哪几种

## 2、谷歌浏览器的核心是？

## 3、打开谷歌会有四个进程，为什么？

## 4、前端怎么解决跨域

## 5、cookies sessionStorage和localstorage区别

## 6、http 和 https 有何区别？如何灵活使用？

## 7、常见的HTTP状态码

## 8、优雅降级和渐进增强

求你打开我的主页看，如果我没记错是有的


## 9、浏览器是如何渲染页面的？

## 10、从输入url到显示页面，都经历了什么

## 11、离线缓存

## 12、浏览器事件流向

## 13、Http报文的请求会有几个部分

## 14、cookie和token都存放在header里面，为什么只劫持前者

## 15、如何设计一个localStorage，保证数据的实效性

## 16、http缓存控制

## 17、xsrf跨域攻击的安全性问题怎么防范

## 18、EventLoop的理解

## 19、浏览器渲染触发在EventLoop的哪个阶段，触发机制是怎么样的

## 20、HTTP的几种请求方法用途

## 21、介绍一下你对浏览器内核的理解？

## 22、HTML5的离线储存怎么使用，工作原理能不能解释一下？

## 23、浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢

## 24、iframe有那些缺点？

## 25、ajax原理

## 26、模块化开发怎么做？

## 27、web开发中会话跟踪的方法有哪些

## 28、强缓存和协商缓存的过程

## 



# 2021前端面试题–vue篇

## 1、多个组件之间如何拆分各自的state，每块小的组件有自己的状态，它们之间还有一些公共的状态需要维护，如何思考这块？

（1）公共的数据部分可以提升至和他们最近的父组件，由父组件派发
（2）公共数据可以放到vuex中统一管理，各组件分别获取


## 2、key主要是解决哪一类的问题，为什么不建议用索引index（重绘）

（1）key的作用主要是为了高效的更新虚拟DOM
（2）当以index为key值时，如果数组长度发生变化，会导致key的变化，比如删除其中某一项，那么index会相应变化。
所以用index作为key和不加index没有什么区别，都不能提升性能。一般用每项数据的唯一值来作为key，就算数组长度变化，也不会影响到这个key


## 3、介绍虚拟DOM`

（1）让我们不用直接操作DOM元素，只操作数据便可以重新渲染页面
（2）虚拟dom
虚拟dom是为了解决浏览器性能问题而被设计出来的
当操作数据时，将改变的dom元素缓存起来，都计算完后再通过比较映射到真实的dom树上
（3）diff算法比较新旧虚拟dom
如果节点类型相同，则比较数据，修改数据
如果节点不同，直接干掉节点及所有子节点，插入新的节点
如果给每个节点都设置了唯一的key，就可以准确的找到需要改变的内容，否则就会出现修改一个地方导致其他地方都改变的情况。
比如A-B-C-D, 我要插入新节点A-B-M-C-D,实际上改变的了C和D。但是设置了key，就可以准确的找到B C并插入


## 4、介绍高阶组件

？？？？？别问，问就是自己百度算我求你了！


## 5、如何解决props层级过深的问题

(1)使用vuex
(2)传递数据，使用以下接收（均不含被props接收的数据）
this.$attrs 接收属性
this.$listeners 接收事件（不含被 .native 修饰符的事件）


## 6、vue中如何编写可复用的组件

（1）以组件功能命名
（2）只负责ui的展示和交互动画，不要在组件里与服务器打交道（获取异步数据等）
（3）可复用组件不会因组件使用的位置、场景而变化。尽量减少对外部条件的依赖。


## 7、vue中对象更改检测的注意事项



## 8、解决非工程化项目初始化页面闪动问题

vue页面在加载的时候闪烁花括号{{}}，使用v-cloak，隐藏未编译时候的标签

```
//css样式
[v-cloak] {
    display: none;
}

//html代码
<div v-cloak>
   <ul>
      <li >{{ text }}</li>
   </ul>
</div>
```



## 9、十个常用的自定义过滤器

（1）去除空格
（2）时间转换
（3）大小写转换
（4）字符串替换
（5）金额字符转金额/数字转金额字符
（6）保留两位小数
（7）判断字符串长度并省略
...
根据自己常用的来说（不然容易尬住，你懂得hhhhhh）


## 10、vue弹窗后如何禁止滚动条滚动？

```
methods : {
   //禁止滚动
   stop(){
        var mo=function(e){e.preventDefault();};
        document.body.style.overflow='hidden';
        document.addEventListener("touchmove",mo,false);//禁止页面滑动
    },
    /***取消滑动限制***/
    move(){
        var mo=function(e){e.preventDefault();};
        document.body.style.overflow='';//出现滚动条
        document.removeEventListener("touchmove",mo,false);
    }
```



## 11、完整的 vue-router 导航解析流程

- 1、导航被触发
- 2、在失活的组件里调用 beforeRouteLeave 守卫
- 3、调用全局 beforeEach 前置守卫
- 4、重用的组件调用 beforeRouteUpdate 守卫（2.2+）
- 5、路由配置调用 beforeEnter
- 6、解析异步路由组件
- 7、在被激活的组件里调用 beforeRouteEnter 守卫
- 8、调用全局的 beforeResolve 守卫（2.5+）
- 9、导航被确认
- 10、调用全局的 afterEach
- 11、触发 DOM 更新
- 12、调用  beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入

————————————————
版权声明：本文为CSDN博主「行行_出状元」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/lq099526/article/details/123252453

## 12、vue-router的几种实例方法以及参数传递

### 实例方法： 

| 实例方法                                              | 说明                                                         |
| ----------------------------------------------------- | ------------------------------------------------------------ |
| this.$router.push(location, onComplete?, onAbort?)    | 这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。并且点击 `<router-link :to="...">`等同于调用 `router.push(...)`。 |
| this.$router.replace(location, onComplete?, onAbort?) | 这个方法不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录，所以，当用户点击浏览器后退按钮时，并不会回到之前的 URL。 |
| this.$router.go(n)                                    | 这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 `window.history.go(n)`。 |

注意：

1、在 2.2.0+，可选的在 `router.push` 或 `router.replace` 中提供 `onComplete` 和 `onAbort` 回调作为第二个和第三个参数。这些回调将会在`导航成功完成` (在所有的异步钩子被解析之后) 或`终止` (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的`调用`。

2、如果`目的地`和`当前路由相同`，只有`参数发生了改变` (比如从一个用户资料到另一个 `/users/1 -> /users/2`)，你需要使用 `beforeRouteUpdate` 来响应这个变化 (比如抓取用户信息)。

### 参数传递方式：

vue-router提供了`params`、`query`、`meta`三种页面间传递参数的方式。

示例：

```
// 字符串，不带参数
this.$router.push('home')

// 对象，不带参数
this.$router.push({ path: 'home' })

// params（推荐）：命名的路由，params 必须和 name 搭配使用
this.$router.push({ name:'user',params: { userId: 123 }})

// 这里的 params 不生效
this.$router.push({ path:'/user',params: { userId: 123 }})

// query：带查询参数，变成 /register?plan=private
this.$router.push({ path: 'register', query: { plan: 'private' }})

//meta方式：路由元信息
export default new Router({
    routes: [
        {
            path: '/user',
            name: 'user',
            component: user,
            meta:{
                title:'个人中心'
            }
        }
    ]
})
```

在`组件`中使用： 

```
//通过 $route 对象获取，注意是route，么有r
this.$route.params

this.$route.query

this.$route.meta
```

```
$route和$router的区别 

`$route`是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。 

`$router`是“路由实例”对象包括了路由的跳转方法，钩子函数等
```

。 

## 13、vue-router如何定义嵌套路由？

`嵌套路由:`是路由的多层嵌套。 

`第一步：`需要在一个被渲染的组件中嵌套 `<router-view>`组件。 例如，在 `User` 组件的模板添加一个 `<router-view>`： 

```
const User = {
  template: `
    <div class="user">
      <h2>User</h2>
      <router-view></router-view>
    </div>
  `

```

`第二步：`在嵌套的出口中渲染组件，在`VueRouter` 的参数中使用`children`配置： 

```
const router = new VueRouter({
  routes: [
    { 
      path: '/user/:id', 
      component: User,
      children: [
        {
          // 当 /user/:id/profile 匹配成功，
          // UserProfile 会被渲染在 User 的 <router-view> 中
          path: 'profile',
          component: UserProfile
        },
        {
          // 当 /user/:id/posts 匹配成功
          // UserPosts 会被渲染在 User 的 <router-view> 中
          path: 'posts',
          component: UserPosts
        }
      ]
    }
  ]
})
```

`注意：`children 配置就是`像 routes 配置一样`的路由`配置数组`，所以呢，你`可以嵌套多层路由`。

`注意：`如果基于上面的配置，当你访问 `/user/foo`时，User 的`出口是不会`渲染任何东西，这是`因为没有匹配到合适的子路由`。如果你想要渲染点什么，可以`提供一个 空的 子路由：`

```
const router = new VueRouter({
  routes: [
    {
      path: '/user/:id', 
      component: User,
      children: [
        // 当 /user/:id 匹配成功，
        // UserHome 会被渲染在 User 的 <router-view> 中
        { path: '', component: UserHome },
 
        // ...其他子路由
      ]
    }
  ]
});
```



## 14、vue-router如何实现路由懒加载（ 动态加载路由 ）

### 1.什么是路由懒加载？

​    也叫延迟加载，即在需要的时候进行加载，随用随载。

### 2.官方解释：

​	1：当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。
	2：如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。


### 3.官方在说什么呢？为什么需要懒加载？

​	1：首先，我们知道路由中通常会定义很多不同的页面。
	2：这个页面这项目build打包后，一般情况下，会放在一个单独的js文件中
	3：但是，如果很多的页面都放在同一个js文件中，必然会造成这个页面非常大
	4：如果我们一次性的从服务器中请求下来这个页面，可能会花费一定时间，用户体验不好
	5：如何避免这种情况发生呢？使用路由懒加载就可以了


### 4.继续解释原由？

​    1：像vue这种单页面应用，如果没有应用懒加载，运用webpack打包后的文件将会异常的大。
    2：造成进入首页时，需要加载的内容过多，时间过长，会出啊先长时间的白屏，即使做了loading也是不利于用户体验。
    3：而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时

也就是说：进入页面不用也不需要一次性加载过多资源造成加载时间过程！

### 5.路由懒加载做了什么事情？

​	1：主要作用是将路由对应的组件打包成一个个的js代码块
	2：只有在这个路由被访问到的时候，才加载对应的组件，否则不加载！


### 即：只有在这个路由被访问到的时候，才加载对应的组件，否则不加载！

### 1:.如何实现路由懒加载？？

 vue项目实现路由按需加载（路由懒加载）的三种方式：
 	1：Vue异步组件
 	2：ES6标准语法import（）---------推荐使用！！！！！
 	3：webpack的require，ensure()


### 2.Vue异步加载技术

 	1：vue-router配置路由，使用vue的异步组件技术，可以实现懒加载，此时一个组件会生成一个js文件。
 	2：component: resolve => require(['放入需要加载的路由地址'], resolve)


```
 {
      path: '/problem',
      name: 'problem',
      component: resolve => require(['../pages/home/problemList'], resolve)
    }
```




### 3.ES6推荐方式imprort ()----推荐使用

 	1：直接将组件引入的方式，import是ES6的一个语法标准，如果需要浏览器兼容，需要转化成es5的语法。
 	2：推荐使用这种方式，但是注意wepack的版本>2.4
 	3：vue官方文档中使用的也是import实现路由懒加载
 	4：上面声明导入，下面直接使用


```
import Vue from 'vue';
import Router from 'vue-router';
// 官网可知：下面没有指定webpackChunkName，每个组件打包成一个js文件。
const Foo = () => import('../components/Foo')
const Aoo = () => import('../components/Aoo')
// 下面2行代码，指定了相同的webpackChunkName，会合并打包成一个js文件。
// const Foo = () => import(/* webpackChunkName: 'ImportFuncDemo' */ '../components/Foo')
// const Aoo = () => import(/* webpackChunkName: 'ImportFuncDemo' */ '../components/Aoo')
export default new Router({
    routes: [
        {
            path: '/Foo',
            name: 'Foo',
            component: Foo
        },
        {
            path: '/Aoo',
            name: 'Aoo',
            component: Aoo
        }
    ]
})
```



### 4.webpack提供的require.ensure()实现懒加载：

 	1：vue-router配置路由，使用webpack的require.ensure技术，也可以实现按需加载。
 	2：这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。
 	3：require.ensure可实现按需加载资源，包括js,css等。他会给里面require的文件单独打包，不会和主文件打包在一起。
 	4：第一个参数是数组，表明第二个参数里需要依赖的模块，这些会提前加载。
	5：第二个是回调函数,在这个回调函数里面require的文件会被单独打包成一个chunk,不会和主文件打包在一起，这样就生成了两个chunk,第一次加载时只加载主文件。
	6：第三个参数是错误回调。
	7：第四个参数是单独打包的chunk的文件名

————————————————
此处代码参考原文链接：https://blog.csdn.net/qq_41998083/article/details/109726402

```
import Vue from 'vue';
import Router from 'vue-router';
const HelloWorld=resolve=>{
		require.ensure(['@/components/HelloWorld'],()=>{
			resolve(require('@/components/HelloWorld'))
		})
	}
Vue.use('Router')
export default new Router({
	routes:[{
	{path:'./',
	name:'HelloWorld',
	component:HelloWorld
	}
	}]
})


```



### 4.import和require的比较（了解）

1：import 是解构过程并且是编译时执行
2：require 是赋值过程并且是运行时才执行，也就是异步加载
3：require的性能相对于import稍低，因为require是在运行时才引入模块并且还赋值给某个变量

至此：关于VueRouter懒加载的基本知识以及使用方式已经介绍完毕，逻辑道理很简单， 关键在实践，感谢观看！
————————————————
版权声明：本文为CSDN博主「Ajiia」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/czj1049561601/article/details/114120236

## 15、vue-router路由的两种模式

 vue-router中默认使用的是hash模式
（1）hash模式
http://localhost:8080/#/pageA
hash 的值为 #/pageA
改变hash，浏览器本身不会有任何请求服务器动作的，但是页面状态和url已经关联起来了。
（2）history模式
http://localhost:8080/ 正常的而路径，并没有#


## 16、vuex的核心概念

state => 基本数据 
getters => 从基本数据派生的数据 
mutations => 修改数据，同步 
actions => 修改数据，异步 
modules => 模块化Vuex


## 17、vue如何优化首屏加载速度？

（1）按需加载组件，不一次性加载所有组件
（2）减少打包js，如果打包后的js文件过大，会阻塞加载。如下：
A、在index.html文件中：

```
<script src="/static/common/js/vue.min.js"></script>
```


B、在vue.config.js文件中配置:

```
config.externals({
      vue: 'Vue',
 })
```


配置两个步骤，不打包vue
（3）关闭sourcemap，开启压缩代码
vue.config.js文件中配置：productionSourceMap: false,
（4）加个好看的loading效果

## 18、Vue.js 全局运行机制

![img](https://s2.51cto.com/images/blog/202104/25/1aa4355a68755a63f60b34e0896064d9.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=) 

流程分析：

1. 初始化以及挂载init, mount
2. 在进行模板编译compile，将template编译为渲染函数render function
3. 执行render function生成Virtual DOM, render function => VNode tree
4. 再进行响应式依赖收集，render function => getter, setter => Watcher.update => patch。以及使用队列进行异步更新的策略
5. 通过diff算法后进行patch更新视图

Vue.js 全局运行机制
https://blog.51cto.com/u_15127642/2754885

## 19、响应式系统的基本原理



Vue.js 是一款 [MVVM](https://so.csdn.net/so/search?q=MVVM&spm=1001.2101.3001.7020) 框架，数据模型仅仅是普通的 JavaScript 对象，但是对这些对象进行操作时，却能影响对应视图，它的核心实现就是「**响应式系统**」。尽管我们在使用 Vue.js 进行开发时不会直接修改「**响应式系统**」，但是理解它的实现有助于避开一些常见的「**坑**」，也有助于在遇见一些琢磨不透的问题时可以深入其原理来解决它。

### `Object.defineProperty`

首先我们来介绍一下 [`Object.defineProperty`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)，Vue.js就是基于它实现「**响应式系统**」的。

首先是使用方法：

```
/*
    obj: 目标对象
    prop: 需要操作的目标对象的属性名
    descriptor: 描述符
    return value 传入对象
*/
Object.defineProperty(obj, prop, descriptor)
```

descriptor的一些属性，简单介绍几个属性，具体可以参考 [MDN 文档](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)。

- `enumerable`，属性是否可枚举，默认 false。
- `configurable`，属性是否可以被修改或者删除，默认 false。
- `get`，获取属性的方法。
- `set`，设置属性的方法。

### 实现 `observer`（可观察的）

知道了 `Object.defineProperty` 以后，我们来用它使对象变成可观察的。

这一部分的内容我们在第二小节中已经初步介绍过，在 `init` 的阶段会进行初始化，对数据进行「**响应式化**」。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcua2FuY2xvdWQuY24vYzQvZGQvYzRkZDY5NWQxYzQ0MjNhZWI4ZWE1NWU2N2ZmZjQ4NmRfODI4eDMzNi5naWY)

为了便于理解，我们不考虑数组等复杂的情况，只对对象进行处理。

首先我们定义一个 `cb` 函数，这个函数用来模拟视图更新，调用它即代表更新视图，内部可以是一些更新视图的方法。

```
function cb (val) {
    /* 渲染视图 */
    console.log("视图更新啦～");
}
```

然后我们定义一个 `defineReactive` ，这个方法通过 `Object.defineProperty` 来实现对对象的「**响应式**」化，入参是一个 obj（需要绑定的对象）、key（obj的某一个属性），val（具体的值）。经过 `defineReactive` 处理以后，我们的 obj 的 key 属性在「读」的时候会触发 `reactiveGetter` 方法，而在该属性被「写」的时候则会触发 `reactiveSetter` 方法。

```
function defineReactive (obj, key, val) {
    Object.defineProperty(obj, key, {
        enumerable: true,       /* 属性可枚举 */
        configurable: true,     /* 属性可被修改或删除 */
        get: function reactiveGetter () {
            return val;         /* 实际上会依赖收集，下一小节会讲 */
        },
        set: function reactiveSetter (newVal) {
            if (newVal === val) return;
            cb(newVal);
        }
    });
}
```

当然这是不够的，我们需要在上面再封装一层 `observer` 。这个函数传入一个 value（需要「**响应式**」化的对象），通过遍历所有属性的方式对该对象的每一个属性都通过 `defineReactive` 处理。（注：实际上 observer 会进行递归调用，为了便于理解去掉了递归的过程）

```
function observer (value) {
    if (!value || (typeof value !== 'object')) {
        return;
    }
    Object.keys(value).forEach((key) => {
        defineReactive(value, key, value[key]);
    });
}
```

最后，让我们用 `observer` 来封装一个 Vue 吧！

在 Vue 的构造函数中，对 `options` 的 `data` 进行处理，这里的 `data` 想必大家很熟悉，就是平时我们在写 Vue 项目时组件中的 `data` 属性（实际上是一个函数，这里当作一个对象来简单处理）。

```
class Vue {

    /* Vue构造类 */
    constructor(options) {
        this._data = options.data;
        observer(this._data);
    }
}
```

这样我们只要 new 一个 Vue 对象，就会将 `data` 中的数据进行「**响应式**」化。如果我们对 `data` 的属性进行下面的操作，就会触发 `cb` 方法更新视图。

```
let o = new Vue({
    data: {
        test: "I am test."
    }
});
o._data.test = "hello,world.";  /* 视图更新啦～ */
```

至此，响应式原理已经介绍完了，接下来让我们学习「**响应式系统**」的另一部分 ——「**依赖收集**」。

注：本节代码参考[《响应式系统的基本原理》](https://github.com/answershuto/VueDemo/blob/master/%E3%80%8A%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E3%80%8B.js)。

## 20、怎么注册插件

使用全局方法Vue.use()
Vue.use( MyPlugin )

com.js中
import com from './xx.vue'
let test = {}
test.install = function(Vue,options){
    Vue.component(panel.name, panel)  // 注册全局组件
}
export default com

main.js中
import com from './com.js'
Vue.use(com)

所有vue文件中都可以调用组件<com></com>



## 21、如何编译template 模板？

compile编译会有三个过程
（1）parse 根据正则进行字符串解析，得到指令、class、style等数据，形成语法树（AST）
（2）对 parse 生成的 AST 进行静态内容的优化，标记静态节点（和数据没有关系不需要每次都刷新的内容），标记静态根节点。
（3）generate 生成 render
生成 render 的 generate 函数的输入也是 AST，它递归了 AST 树，为不同的 AST 节点创建了不同的内部调用方法，等待后面的调用。

看不懂的给你们直通车：https://segmentfault.com/a/1190000012922342


## 22、diff算法

diff算法比较新旧虚拟dom
如果节点类型相同，则比较数据，修改数据
如果节点不同，直接干掉节点及所有子节点，插入新的节点
如果给每个节点都设置了唯一的key，就可以准确的找到需要改变的内容，否则就会出现修改一个地方导致其他地方都改变的情况。比如A-B-C-D, 我要插入新节点A-B-M-C-D,实际上改变的了C和D。但是设置了key，就可以准确的找到B C并插入


## 23、批量异步更新策略及 nextTick 原理？

（1）批量异步策略
Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。
（2）nextTick
在下一次DOM更新循环结束之后执行延迟回调


## 24、vue中proxy代理？

一、proxy常用参数说明

```
module.exports = {
    publicPath: "/",
    devServer: {
        proxy: {
            "/api": {
                // 代理名称   凡是使用/api开头的地址都是用此代理
                target: "http://1.2.3.4:5000/", // 需要代理访问的api地址
                changeOrigin: true, // 允许跨域请求
                pathRewrite: {
                    // 重写路径，替换请求地址中的指定路径
                    "^/api": "/", // 将请求地址中的/api替换为空，也就是请求地址中不会包含/api/
                },
            },
        },
    },
};
```


二、关于/api的详解
‘/api’：是指遇到这个字符开头的话，在这个字符前面加上target里面的ip或者域名。

举例：
①登录接口：http://1.2.3.4:5000/login
…中间省略了配置过程…
②npm run serve:Local: http://localhost:8080/
③点击后发送的登录请求：http://localhost:8080/api/login
④/api 的作用就是将/api前的localhost：8080变成target的内容http://1.2.3.4:5000/
⑤完整的路径变成了http://1.2.3.4:5000/api/login
⑥实际接口当中没有这个api，所以pathwrite重写就解决这个问题的。
⑦pathwrite识别到api开头就会把/api重写成空，那就是不存在这个/apil了，完整的路径又变成：http://1.2.3.4:5000/login


三、部署因为/api无法请求到数据
接口名称不用/api，改用实际接口的第一个字段，然后取消pathwrite重写
————————————————
版权声明：本文为CSDN博主「Litt_White」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/Litt_White/article/details/124636218

## 25、vue开发命令 npm run dev 输入后的执行过程

（1）npm run dev是执行配置在package.json中的脚本
（2）调用了webpack配置文件
（3）配置文件中调用了main.js
（4）main.js用到了一个html元素#app，引用路由等开始vue的模板编译


## 26、devDependencies和dependencies的区别

（1）devDependencies
用于本地开发，打包时生产环境不会打包这些依赖
（2）dependencies
开发环境能用，生产环境也能用。生产环境会被打包


## 27、依赖版本~和^的区别

（1）~
会匹配最近的小版本依赖包，比如~1.2.3会匹配所有1.2.x版本，但是不包括1.3.0
（2）^
会匹配最新的大版本依赖包，比如^1.2.3会匹配所有1.x.x的包，包括1.3.0，但是不包括2.0.0


## 28、插件机制

Vue是支持插件的，而且它的插件机制很简单。就是用Vue.use方法，接收一个函数。接收的这个函数就是用来插件，它能做的事情无非就是在Vue或Vue.prototoye上添加一些方法啥的。让你在Vue上或Vue实例上可以调用你插件提供的功能。

在使用use注册插件的时候就会调用你传递过来的函数，这个函数接收的参数是你调用use时传递来的除了这个函数之外的所有参数，同时还会把Vue放到第一个参数的位置。就是const args = toArray(arguments, 1)
args.unshift(this)这两句。

在core/global-api/use.js

    Vue.use = function (plugin: Function | Object) {
        const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))
        if (installedPlugins.indexOf(plugin) > -1) {
          return this
        }
    // additional parameters
    const args = toArray(arguments, 1)
    args.unshift(this)
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args)
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args)
    }
    installedPlugins.push(plugin)
    return this
  }
————————————————
版权声明：本文为CSDN博主「nothing_more_than」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/txyzqc/article/details/105134721

## 29、router的meta有什么用

在meta对象中可以设置一些状态，通常设置标题或是否需要缓存。$route.meta.keepAlive/$route.meta.title
{
    path:"/test",
    name:"test",
    component:()=>import("@/components/test"),
    meta:{
        title:"测试页面", //配置title
        keepAlive: true //是否缓存
    }
}


## 30、如果子组件直接修改父组件的值会发生什么？怎么解决，要修改多个数据怎么办？

如果修改的不是引用类型的值时会报错，告诉我们不能直接修改父组件的值。
(1)可以使用.sync修饰符来修改值，对一个 prop 进行“双向绑定”。（注意.sync 修饰符的 v-bind 不能和表达式一起使用）
(2)父组件将改变值的方法传递给子组件


# 2021前端面试题–webpack篇

## 1、webpack里面的插件是怎么实现的

## 2、dev-server是怎么跑起来

## 3、使用过webpack里面哪些plugin和loader

## 4、webpack整个生命周期，loader和plugin有什么区别

## 5、webpack打包的整个过程

## 6、一般怎么组织CSS（Webpack）

## 7、如何配置把js、css、html单独打包成一个文件

## 8、webpack和gulp的优缺点

## 9、使用webpack构建时有无做一些自定义操作

## 10、webpack的热更新是如何做到的？说明其原理？

（下次再更！）

# 2021年前端面试题-通信/编程/原理篇

为什么会有这个篇章呢？
这些都是计算机或编程方面的一些知识点啦爱记不记！

## 一、原理篇

### 1、介绍观察者模式

### 2、介绍中介者模式

### 3、观察者和订阅-发布的区别，各自用在哪里

### 4、介绍事件代理以及优缺点

### 5、tcp3次握手

### 6、tcp属于哪一层（1 物理层 -> 2 数据链路层 -> 3 网络层(ip)-> 4 传输层(tcp) -> 5 应用层(http)）

### 7、前端开发中用到哪些设计模式

### 8、介绍下数字签名的原理

### 8、Promise.all实现原理

## 二、算法/编程篇

### 1、介绍AST（Abstract Syntax Tree）抽象语法树

### 2、柯里化函数两端的参数具体是什么东西

### 3、介绍二叉搜索树的特点

### 4、[1, 2, 3, 4, 5]变成[1, 2, 3, a, b, 5]

### 5、如何找0-5的随机数，95-99呢

### 6、手写数组扁平化函数

### 7、写一个倒计时函数

### 8、写一个函数，给定一棵树，输出这棵树的深度

### 9、写一个函数，给定一个url和最大深度maxdeep，输出抓取当前url及其子链接深度范围内的所有图片

### 10、写一个函数，给定nodes=[]，每一个节点拥有id,name,parentid，输出一个属性列表的展示(涉及dom操作)

### 11、"123456789876543212345678987654321…"的第n位是什么？

## 三、测试篇

### 1、前端怎么做单元测试

### 2、pm2怎么做进程管理，进程挂掉怎么处理

### 3、不用pm2怎么做进程管理

## 四、了解篇

### 1、对PWA有什么了解

### 2、RESTful常用的Method

### 3、base64为什么能提升性能，缺点

### 4、介绍webp这个图片文件格式

### 5、介绍DNS解析

### 6、介绍SSL和TLS

### 7、介绍异步方案

### 8、对无状态组件的理解

### 9、介绍快速排序

### 10、介绍下DFS深度优先

## 五、通信篇

### 1、ajax如何处理跨域

### 2、Ajax发生跨域要设置什么（前端）

### 3、跨域jsonp方案需要服务端怎么配合

### 4、Async里面有多个await请求，可以怎么优化（请求是否有依赖）

### 5、ajax的步骤

### 6、CORS如何设置

### 7、jsonp为什么不支持post方法

### 8、axios有什么特点？

## 六、优化及语义

### 1、前端需要注意哪些SEO

### 2、如何进行网站性能优化

### 3、语义化的理解

### 4、CSS在性能优化方面的实践

————————————————
版权声明：本文为CSDN博主「渔老板」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_54840593/article/details/116936840